#!/usr/bin/env node
/**
 * Policy Crystallizer v0 (Week 6 Learning Pipeline)
 * SSOT: .claude/scripts/learning/policy_crystallizer_v0.mjs
 *
 * Control Plane component: crystallizes detected patterns into learned policies.
 * Writes policies to state/memory/learned/policies/sandbox/ directory.
 *
 * Stub implementation for Week 6 bootstrap.
 *
 * Usage:
 *   node .claude/scripts/learning/policy_crystallizer_v0.mjs [--dry-run]
 *
 * Input: Reads patterns from stdin (output of pattern_detector_v0)
 * Output: JSON with crystallized policy count or dry-run preview
 */

import { readFileSync, writeFileSync, mkdirSync, existsSync } from 'fs';
import { join } from 'path';
import { createHash } from 'crypto';

const POLICIES_DIR = 'state/memory/learned/policies';
const SANDBOX_DIR = join(POLICIES_DIR, 'sandbox');

/**
 * Generate a policy ID from pattern characteristics
 * @param {Object} pattern - Detected pattern
 * @returns {string} Policy ID in uppercase snake_case
 */
function generatePolicyId(pattern) {
  const actionType = (pattern.action_type || 'UNKNOWN').toUpperCase().replace(/-/g, '_');
  const scope = (pattern.scope?.type || 'GLOBAL').toUpperCase();
  const hash = createHash('sha256')
    .update(JSON.stringify(pattern))
    .digest('hex')
    .slice(0, 6)
    .toUpperCase();

  return `${actionType}_${scope}_${hash}`;
}

/**
 * Convert a pattern to a learned policy YAML structure
 * @param {Object} pattern - Detected pattern with success signals
 * @returns {Object} Policy object conforming to learned_policy.schema.yaml
 */
function patternToPolicy(pattern) {
  const now = new Date().toISOString();
  const policyId = generatePolicyId(pattern);

  return {
    schema_version: '1.0.0',
    policy_id: policyId,
    domain: pattern.domain || 'unknown',
    learned_at: now,
    scope: pattern.scope || { type: 'global', keys: {} },
    risk_level: pattern.risk_level || 'medium',
    validation_status: 'sandbox',  // Always start in sandbox
    confidence: pattern.success_rates?.exec || 0.5,
    preconditions: pattern.preconditions || {},
    actions: pattern.actions || [{
      action_type: pattern.action_type || 'investigate_metric',
      parameters: pattern.parameters || {},
      dry_run_compatible: true
    }],
    constraints: {
      max_bid_change_pct: 30,
      max_actions_per_day: 5
    },
    rollback_plan: {
      type: 'automatic',
      steps: ['Revert to previous state', 'Wait 24h for stabilization']
    },
    success_signals: {
      exec: {
        count: pattern.frequency || 0,
        success_rate: pattern.success_rates?.exec || 0
      },
      operator: {
        approval_count: 0,
        rejection_count: 0,
        approval_rate: null  // Not measured in sandbox
      },
      business: {
        metric_name: pattern.metric_name || 'unknown',
        baseline: null,
        current: null,
        improvement_pct: null,
        sample_size: null
      }
    },
    evaluation_window_days: 7,
    expiry_at: new Date(Date.now() + 90 * 24 * 60 * 60 * 1000).toISOString(),
    evidence: pattern.evidence || []
  };
}

/**
 * Write policy to sandbox directory
 * @param {Object} policy - Policy object
 * @param {boolean} dryRun - If true, don't write to disk
 * @returns {string} Path to written file (or would-be path in dry-run)
 */
function writePolicy(policy, dryRun = false) {
  mkdirSync(SANDBOX_DIR, { recursive: true });

  const filename = `${policy.policy_id}.yaml`;
  const filepath = join(SANDBOX_DIR, filename);

  if (!dryRun) {
    // Week 6 stub: would use YAML serializer
    // For now, write as JSON with .yaml extension
    const content = `# Learned Policy (auto-generated by policy_crystallizer_v0)
# Schema: _meta/contracts/learning/learned_policy.schema.yaml

${JSON.stringify(policy, null, 2)}
`;
    writeFileSync(filepath, content);
    console.error(`[policy_crystallizer_v0] Wrote: ${filepath}`);
  } else {
    console.error(`[policy_crystallizer_v0] Dry-run: would write ${filepath}`);
  }

  return filepath;
}

/**
 * Crystallize patterns into policies
 * @param {Array} patterns - Detected patterns from pattern_detector
 * @param {boolean} dryRun - If true, don't write to disk
 * @returns {Array} Created policies
 */
function crystallize(patterns, dryRun = false) {
  const policies = [];

  for (const pattern of patterns) {
    // Only crystallize patterns meeting minimum criteria
    if ((pattern.frequency || 0) < 3) {
      console.error(`[policy_crystallizer_v0] Skipping pattern (frequency < 3): ${pattern.action_type}`);
      continue;
    }

    if ((pattern.success_rates?.exec || 0) < 0.7) {
      console.error(`[policy_crystallizer_v0] Skipping pattern (exec_rate < 0.7): ${pattern.action_type}`);
      continue;
    }

    const policy = patternToPolicy(pattern);
    const filepath = writePolicy(policy, dryRun);
    policies.push({ policy_id: policy.policy_id, filepath });
  }

  return policies;
}

/**
 * Main entry point
 */
async function main() {
  const args = process.argv.slice(2);
  const dryRun = args.includes('--dry-run');

  console.error('[policy_crystallizer_v0] Starting crystallization...');
  console.error(`[policy_crystallizer_v0] Dry-run: ${dryRun}`);

  try {
    // Read patterns from stdin
    let inputData = '';

    if (!process.stdin.isTTY) {
      inputData = readFileSync(0, 'utf-8');
    }

    if (!inputData.trim()) {
      // Week 6 stub: no input patterns
      console.error('[policy_crystallizer_v0] No patterns in stdin (stub mode)');
      const result = {
        status: 'success',
        timestamp: new Date().toISOString(),
        dry_run: dryRun,
        patterns_received: 0,
        policies_created: 0,
        policies: []
      };
      console.log(JSON.stringify(result, null, 2));
      process.exit(0);
    }

    const input = JSON.parse(inputData);
    const patterns = input.patterns || [];

    console.error(`[policy_crystallizer_v0] Received ${patterns.length} patterns`);

    // Crystallize patterns into policies
    const policies = crystallize(patterns, dryRun);

    const result = {
      status: 'success',
      timestamp: new Date().toISOString(),
      dry_run: dryRun,
      patterns_received: patterns.length,
      policies_created: policies.length,
      policies: policies
    };

    console.log(JSON.stringify(result, null, 2));
    process.exit(0);

  } catch (error) {
    const result = {
      status: 'error',
      timestamp: new Date().toISOString(),
      error: {
        code: 'CRYSTALLIZATION_FAILED',
        message: error.message
      }
    };

    console.log(JSON.stringify(result, null, 2));
    process.exit(1);
  }
}

// Only run if directly executed
const isDirectRun = process.argv[1]?.endsWith('policy_crystallizer_v0.mjs');
if (isDirectRun) {
  main();
}

export { generatePolicyId, patternToPolicy, crystallize };
