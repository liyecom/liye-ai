# Runtime Policy Layer

> **This layer performs a priori action adjudication.**

The Runtime Policy Layer is the AI OS's prior security kernel. Every action generated by AI must pass through policy evaluation before execution.

## Purpose

- **A Priori Adjudication**: Decisions are made BEFORE actions execute
- **Non-bypassable**: There is no code path that skips evaluation
- **Fail-Close**: Any error during evaluation results in DENY
- **Auditable**: Every decision is logged with full context

## Architecture

```
┌─────────────────────────────────────────────────────────────────┐
│                      AI Agent / LLM                             │
│                           │                                     │
│                           ▼                                     │
│                    ┌─────────────┐                              │
│                    │   Action    │                              │
│                    └──────┬──────┘                              │
│                           │                                     │
│            ╔══════════════▼══════════════╗                      │
│            ║     POLICY ENGINE           ║                      │
│            ║  ┌────────────────────────┐ ║                      │
│            ║  │   Policy Registry      │ ║                      │
│            ║  │   (6 policies loaded)  │ ║                      │
│            ║  └────────────────────────┘ ║                      │
│            ║  ┌────────────────────────┐ ║                      │
│            ║  │   Policy Evaluator     │ ║                      │
│            ║  │   (condition matching) │ ║                      │
│            ║  └────────────────────────┘ ║                      │
│            ║  ┌────────────────────────┐ ║                      │
│            ║  │   Decision Logger      │ ║                      │
│            ║  │   (audit trail)        │ ║                      │
│            ║  └────────────────────────┘ ║                      │
│            ╚══════════════╤══════════════╝                      │
│                           │                                     │
│                           ▼                                     │
│                    ┌─────────────┐                              │
│                    │  Decision   │                              │
│                    │ ALLOW/DENY  │                              │
│                    └──────┬──────┘                              │
│                           │                                     │
│              ┌────────────┴────────────┐                        │
│              ▼                         ▼                        │
│         ┌────────┐               ┌──────────┐                   │
│         │ ALLOW  │               │   DENY   │                   │
│         │Execute │               │  Block   │                   │
│         └────────┘               └──────────┘                   │
└─────────────────────────────────────────────────────────────────┘
```

## Call Sequence

```
1. Agent generates Action
2. Action → PolicyEngine.evaluate()
3. Engine loads policies from Registry
4. For each Policy:
   └─ Evaluator.evaluate(action, policy)
      └─ If DENY → Return immediately
5. If no DENY → Return ALLOW
6. Decision → Logger
7. Caller receives Decision
```

## Relationship to GitHub / CI Governance

| Layer | Timing | Scope | Enforcement |
|-------|--------|-------|-------------|
| **CI Gates** | Post-commit | Code changes | GitHub Actions |
| **Branch Protection** | On push/PR | Git operations | GitHub |
| **CODEOWNERS** | On PR | Review requirement | GitHub |
| **Runtime Policy** | Pre-action | All AI actions | Policy Engine |

The Runtime Policy Layer complements CI/GitHub governance:
- CI catches issues AFTER code is committed
- Runtime Policy prevents issues BEFORE actions execute

## Policies

| ID | Name | Purpose |
|----|------|---------|
| POL_001 | Branch Scope | Protect main branch |
| POL_002 | File Class | Protect workflow files |
| POL_003 | Policy Immutability | Self-protection |
| POL_004 | Tool Allowlist | Restrict tool usage |
| POL_005 | Rate Guard | Prevent action storms |
| POL_006 | Fail-Close | Safety net for errors |

## Usage

```python
from src.runtime.policy import PolicyEngine, Action

# Create engine (loads policies automatically)
engine = PolicyEngine()

# Create an action
action = Action.create(
    action_type="file.write",
    target="/path/to/file",
    metadata={"tool_name": "write"}
)

# Evaluate
decision = engine.evaluate(action)

if decision.is_denied():
    print(f"Action blocked: {decision.reason}")
else:
    # Safe to proceed
    execute_action(action)
```

## Invariants

1. **No Bypass**: `PolicyEngine.evaluate()` is the ONLY entry point
2. **Deny First**: Single DENY = action blocked
3. **Fail-Close**: Errors = DENY
4. **Immutable Policies**: YAML files are read-only at runtime

## File Structure

```
src/runtime/policy/
├── __init__.py           # Module exports
├── engine.py             # Policy Engine (core)
├── registry.py           # Policy Registry
├── models.py             # Data models
├── evaluator.py          # Policy Evaluator
├── exceptions.py         # Exception types
├── decision_logger.py    # Audit logging
├── policies/
│   ├── POL_001_branch_scope.yaml
│   ├── POL_002_file_class.yaml
│   ├── POL_003_policy_immutability.yaml
│   ├── POL_004_tool_allowlist.yaml
│   ├── POL_005_rate_guard.yaml
│   └── POL_006_fail_close.yaml
└── README.md
```

## Security Considerations

- Policy files are YAML (human-readable, auditable)
- Registry is read-only after initialization
- Evaluator has no side effects
- All decisions are logged
- Exceptions trigger fail-close

## Replan Hint (Non-Executable)

DENY decisions include optional `suggestion` and `alternative` fields that provide minimal viable alternative paths for re-planning.

**Key Principles**:

1. **Runtime Policy does not re-plan.** The Policy Engine only adjudicates; it never modifies actions or triggers retries.

2. **Decisions provide minimal viable alternatives.** Each DENY includes a `suggestion` (human-readable hint) and optionally an `alternative` (structured hint with specific parameters).

3. **Planner/Agent may choose to adopt or ignore.** The hints are advisory, not prescriptive. The caller decides whether to re-plan based on the suggestion.

> **"Denied actions should collapse into constrained planning, not retries."**

**Example Decision with Replan Hint**:

```python
Decision(
    decision_id="...",
    action_id="...",
    policy_id="POL_001_branch_scope",
    result=DecisionResult.DENY,
    reason="Policy Branch Scope Protection: Deny direct push to main",
    suggestion="Create a feature/* branch and open a PR",
    alternative={"target_pattern": "refs/heads/feature/*"}
)
```

**Policy Suggestion Mapping**:

| Policy | Suggestion |
|--------|------------|
| POL_001 | Create a feature/* branch and open a PR |
| POL_002 | Move change to non-governance path |
| POL_003 | Policy layer is immutable; modify via governance process |
| POL_004 | Use an allowed tool or request approval |
| POL_005 | Retry after rate window resets |
| POL_006 | Action denied due to system safety fallback |

## Policy → Planner Contract (Frozen Boundary)

The Runtime Policy Layer defines a minimal contract for downstream Planner/Agent consumption. This contract is append-only and backward compatible.

**Three Immutable Principles**:

1. **"Runtime Policy does not plan, execute, or retry."**
2. **"Planner must treat DENY + severity=hard as a mandatory replan signal."**
3. **"This contract is append-only and backward compatible."**

**DecisionContract Schema**:

```json
{
  "result": "ALLOW" | "DENY",
  "reason": "string",
  "suggestion": "string | null",
  "alternative": "object | null",
  "severity": "hard" | "soft"
}
```

**Severity Semantics**:

| Severity | When | Planner Behavior |
|----------|------|------------------|
| `hard` | All DENY | MUST replan or abort |
| `soft` | All ALLOW | MAY optimize (optional) |

**Contract JSON Example (DENY)**:

```json
{
  "result": "DENY",
  "reason": "POL_001_branch_scope: Deny direct push to main",
  "suggestion": "Create a feature/* branch and open a PR",
  "alternative": {
    "target_pattern": "refs/heads/feature/*"
  },
  "severity": "hard"
}
```

See [POLICY_PLANNER_CONTRACT.md](../../../docs/architecture/POLICY_PLANNER_CONTRACT.md) for the full contract specification.

---

**Version**: 0.3.0 (Contract Boundary)
**Phase**: P3.2 Runtime Policy
**Status**: Implemented
