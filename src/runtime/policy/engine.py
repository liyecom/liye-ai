"""
Policy Engine - Core Runtime Policy Evaluation

This is the central component of the Runtime Policy Layer.
ALL actions MUST pass through PolicyEngine.evaluate() before execution.

ARCHITECTURAL BOUNDARIES:
========================
- Policy Engine â‰  Permission System
  (Permissions determine WHO can do WHAT. Policy Engine determines WHETHER
   an action is safe/allowed regardless of who requested it.)

- Policy Engine â‰  CI
  (CI runs AFTER code is committed. Policy Engine runs BEFORE actions
   are executed - it is a priori, not post hoc.)

- Policy Engine IS the AI OS's Prior Security Kernel
  (Every action generated by AI must pass policy evaluation first.
   This is the safety boundary between AI intent and world effects.)

INVARIANTS:
===========
1. Non-bypassable: There is no code path that executes actions without evaluation
2. Fail-Close: Any exception during evaluation results in DENY
3. Deny-First: If ANY policy denies, the action is denied (no override)
4. Auditable: Every decision is logged with full context
"""

from typing import Optional

from .models import Action, Decision, DecisionResult
from .registry import PolicyRegistry
from .evaluator import PolicyEvaluator, POLICY_SUGGESTIONS
from .decision_logger import DecisionLogger
from .exceptions import (
    PolicyDenied,
    PolicyEvaluationError,
    PolicyRegistryError,
    FailCloseError,
)


class PolicyEngine:
    """
    The Policy Engine performs a priori action adjudication.

    Usage:
        engine = PolicyEngine()
        decision = engine.evaluate(action)

        if decision.is_denied():
            # Action is blocked - do not proceed
            raise PolicyDenied(decision.reason, decision.policy_id, action.id)
        else:
            # Safe to execute action
            execute_action(action)

    CRITICAL:
        - Direct action execution is PROHIBITED
        - All actions MUST call evaluate() first
        - There is no bypass mechanism
    """

    def __init__(
        self,
        registry: Optional[PolicyRegistry] = None,
        evaluator: Optional[PolicyEvaluator] = None,
        logger: Optional[DecisionLogger] = None,
    ):
        """
        Initialize the Policy Engine.

        Args:
            registry: Policy registry (defaults to standard registry)
            evaluator: Policy evaluator (defaults to standard evaluator)
            logger: Decision logger (defaults to standard logger)
        """
        self._registry = registry or PolicyRegistry()
        self._evaluator = evaluator or PolicyEvaluator()
        self._logger = logger or DecisionLogger()

        # Ensure policies are loaded
        try:
            self._registry.load_policies()
        except PolicyRegistryError:
            # If no policies are loaded, we still create the engine
            # but evaluation will fail (fail-close)
            pass

    def evaluate(self, action: Action) -> Decision:
        """
        Evaluate an action against all loaded policies.

        This is the ONLY entry point for action adjudication.

        Algorithm:
        1. Receive action
        2. Load all policies from registry
        3. Evaluate each policy against the action
        4. If ANY policy returns DENY -> return DENY immediately
        5. If ALL policies pass -> return ALLOW
        6. If ANY exception occurs -> return DENY (fail-close)

        Args:
            action: The action to evaluate

        Returns:
            Decision object (ALLOW or DENY)

        Note:
            This method NEVER raises exceptions to the caller.
            All errors result in a DENY decision (fail-close).
        """
        try:
            return self._evaluate_internal(action)
        except Exception as e:
            # Fail-Close: Any unexpected error results in DENY
            suggestion, alternative = POLICY_SUGGESTIONS.get(
                "POL_006_fail_close", (None, None)
            )
            decision = Decision.deny(
                action_id=action.id,
                policy_id="POL_006_fail_close",
                reason=f"Fail-close triggered: {type(e).__name__}: {e}",
                suggestion=suggestion,
                alternative=alternative,
            )
            self._logger.log(decision, action)
            return decision

    def _evaluate_internal(self, action: Action) -> Decision:
        """
        Internal evaluation logic.

        Args:
            action: The action to evaluate

        Returns:
            Decision object

        Raises:
            PolicyRegistryError: If registry access fails
            PolicyEvaluationError: If evaluation fails
        """
        # Get all policies
        policies = self._registry.get_all()

        if not policies:
            # No policies loaded - fail-close
            suggestion, alternative = POLICY_SUGGESTIONS.get(
                "POL_006_fail_close", (None, None)
            )
            decision = Decision.deny(
                action_id=action.id,
                policy_id="POL_006_fail_close",
                reason="No policies loaded - fail-close active",
                suggestion=suggestion,
                alternative=alternative,
            )
            self._logger.log(decision, action)
            return decision

        # Evaluate each policy
        for policy in policies:
            try:
                result = self._evaluator.evaluate(action, policy)

                if result is not None and result.is_denied():
                    # Immediate deny - no need to check further
                    self._logger.log(result, action)
                    return result

            except PolicyEvaluationError as e:
                # Evaluation error - fail-close
                policy_id = e.policy_id or "POL_006_fail_close"
                suggestion, alternative = POLICY_SUGGESTIONS.get(
                    policy_id, POLICY_SUGGESTIONS.get("POL_006_fail_close", (None, None))
                )
                decision = Decision.deny(
                    action_id=action.id,
                    policy_id=policy_id,
                    reason=f"Evaluation error: {e}",
                    suggestion=suggestion,
                    alternative=alternative,
                )
                self._logger.log(decision, action)
                return decision

        # All policies passed - ALLOW
        decision = Decision.allow(
            action_id=action.id,
            policy_id="ENGINE",
            reason="All policies passed"
        )
        self._logger.log(decision, action)
        return decision

    def evaluate_or_raise(self, action: Action) -> Decision:
        """
        Evaluate an action and raise PolicyDenied if denied.

        Convenience method for callers who prefer exception-based flow.

        Args:
            action: The action to evaluate

        Returns:
            Decision (only if ALLOW)

        Raises:
            PolicyDenied: If the action is denied
        """
        decision = self.evaluate(action)

        if decision.is_denied():
            raise PolicyDenied(
                message=decision.reason,
                policy_id=decision.policy_id,
                action_id=action.id
            )

        return decision

    @property
    def policy_count(self) -> int:
        """Return the number of loaded policies."""
        return len(self._registry)
