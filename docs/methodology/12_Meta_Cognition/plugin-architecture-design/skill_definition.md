# 🧠 Plugin Architecture Design Skill

**Version**: 1.0
**Created**: 2025-12-28
**Last Updated**: 2025-12-28
**Status**: Active
**Source**: LiYe OS 实战沉淀

---

## 🔹01. Skill Identity（技能身份）

**Skill Name**: Plugin Architecture Design / 插件化架构设计

**Core Mission**:
元认知技能 - 指导如何将"臃肿的完整集成"转化为"轻量核心 + 按需加载"的插件化架构。适用于任何需要平衡"功能丰富"与"系统轻量"的场景。

**Capability Domain**: Meta Cognition (12_Meta_Cognition)
- 第一性原理分析
- 过度工程化识别
- 简化方案设计
- 用户体验导向

**Target Scenarios**:
- 外部资源集成（如开源项目技能）
- 模块化系统设计
- 功能按需加载架构
- 保持核心轻量的扩展策略

---

## 🔹02. Capability Model（能力模型）

### Key Competencies（核心能力维度）

#### A. 问题诊断
- 识别"功能臃肿"症状
- 量化"使用频率 vs 占用资源"
- 区分核心功能与扩展功能

#### B. 第一性原理分析
```
问题拆解模式：
├── 用户真正需要什么？ → 能力，不是文件
├── 什么是最小必要核心？ → 高频使用 + 无法外置
├── 什么可以按需加载？ → 低频使用 + 可外置
└── 用户应该感知到什么？ → 零感知（理想态）
```

#### C. 过度工程化检测
**警示信号**：
- 为"可能用到"而非"一定用到"设计
- 配置文件比代码还多
- 需要额外学习成本
- 维护成本高于使用价值

#### D. 简化决策
```
简化公式：
最优方案 = 达成目标的最少组件

评估标准：
1. 用户感知 → 越少越好
2. 维护成本 → 越低越好
3. 实施周期 → 越短越好
4. 功能完整 → 必须满足
```

---

## 🔹03. Mental Models / Principles（思维模型 / 原则）

### Core Thinking Frameworks

#### 1. 马斯克决策树
```
提出方案
    │
    ▼
问：这是给谁用的？
    │
    ├── 给用户 → 保留
    └── 给开发者 → 问：用户感知到吗？
                      │
                      ├── 是 → 能隐藏吗？
                      │        │
                      │        ├── 能 → 隐藏
                      │        └── 不能 → 重新设计
                      │
                      └── 否 → 能简化吗？
                               │
                               ├── 能 → 简化
                               └── 不能 → 接受复杂度
```

#### 2. 两轮审议法
```
第一轮：功能完整性
  → 能满足需求吗？
  → 有什么缺失？

第二轮：过度工程化检测
  → 哪些可以去掉？
  → 真的需要这么复杂吗？
  → 用户需要知道这些吗？
```

#### 3. 用户无感知原则
```
最佳体验 = 用户不知道发生了什么，但事情做成了

具体表现：
- 无需手动安装/配置
- 无需学习新命令
- 无需关心资源来源
- 无需等待（或等待可接受）
```

### Unbreakable Principles（不可违反原则）

1. **用户体验优先**：技术方案服务于用户体验，不是反过来
2. **简单胜于复杂**：能用一行代码解决的，不要用十行
3. **延迟决策**：不为"可能"的需求提前设计，YAGNI
4. **迭代优于完美**：先上线最简方案，再按需迭代

---

## 🔹04. Methods & SOPs（方法论 / 操作手册）

### Standard Operating Procedure: Plugin Architecture Design

#### Phase 1: 问题定义
```
Step 1.1 识别臃肿症状
  - 仓库/系统体积过大？
  - 大部分功能使用频率低？
  - 用户抱怨复杂度？

Step 1.2 量化分析
  - 列出所有功能/模块
  - 标记使用频率（高/中/低）
  - 估算资源占用

Step 1.3 定义目标
  - 核心保留多少？
  - 扩展支持多少？
  - 用户感知度目标？
```

#### Phase 2: 第一轮设计
```
Step 2.1 功能完整设计
  - 确保所有需求都能满足
  - 设计分层架构
  - 定义触发机制

Step 2.2 技术选型
  - 选择实现方式
  - 定义接口规范
  - 设计存储策略
```

#### Phase 3: 第二轮简化
```
Step 3.1 过度工程化检查
  问自己：
  ✓ 这个配置文件真的需要吗？
  ✓ 这个 CLI 命令用户会用吗？
  ✓ 这个抽象层值得吗？
  ✓ 能不能用更简单的方式？

Step 3.2 简化决策
  对于每个组件：
  ├── 删除：完全不需要
  ├── 合并：可以并入其他组件
  ├── 隐藏：保留但对用户不可见
  └── 保留：确实必要

Step 3.3 对比分析
  制作对比表：
  | 维度 | 原方案 | 简化方案 |
  |------|--------|----------|
  | 配置文件数 | ... | ... |
  | 用户可见性 | ... | ... |
  | 实施周期 | ... | ... |
```

#### Phase 4: 实施
```
Step 4.1 最小可行实现
  - 只实现核心功能
  - 跳过"可选"功能
  - 保持代码简洁

Step 4.2 端到端测试
  - 模拟真实用户场景
  - 验证无感知体验
  - 确认功能完整

Step 4.3 文档更新
  - 更新 README（鸣谢）
  - 内部技术文档（可选）
  - 不要写用户不需要的文档
```

---

## 🔹05. Execution Protocols（执行协议）

### Pre-Execution Checklist

**必须确认的问题**：
1. ✓ 当前的痛点是什么？（臃肿/复杂/慢？）
2. ✓ 用户真正需要什么能力？
3. ✓ 什么必须保留在核心？
4. ✓ 什么可以按需加载？
5. ✓ 理想的用户感知度是什么？

### Decision-Making Logic

**选择"全集成"**：
→ 功能数量少（<10）
→ 所有功能都是高频使用
→ 体积可接受

**选择"插件化"**：
→ 功能数量多（>20）
→ 大部分低频使用
→ 核心需要保持轻量

---

## 🔹06. Output Structure（标准化交付格式）

### Template: 简化决策表

```markdown
## 方案对比

| 评估维度 | 原方案 | 简化方案 |
|----------|--------|----------|
| 新增文件/仓库 | X | Y |
| 配置文件数量 | X | Y |
| CLI 命令 | 有/无 | 有/无 |
| 用户可见性 | 高/中/低 | 高/中/低 |
| 实施周期 | X 周 | Y 周 |
| 维护成本 | 高/中/低 | 高/中/低 |

## 决策

选择 [简化方案]，因为：
1. [原因1]
2. [原因2]
3. [原因3]
```

---

## 🔹07. Templates & Prompts（模板库）

### 激活 Prompt

```
我需要设计一个插件化架构。

背景：
- 当前问题：[描述臃肿/复杂的症状]
- 功能清单：[列出所有功能]
- 使用频率：[高频/低频分布]

请用第一性原理分析，给出：
1. 核心 vs 扩展的划分
2. 按需加载机制设计
3. 简化迭代（检查过度工程化）
```

### 马斯克模拟 Prompt

```
你是马斯克，召集 10 位专家（5 产品 + 5 技术）开研讨会。

议题：[问题描述]

要求：
1. 第一性原理分析
2. 两轮审议（功能完整 → 简化）
3. 对比表格
4. 最终决策
```

---

## 🔹08. Tools Access / Knowledge Assets（工具 & 知识接口）

### Required Knowledge

**LiYe OS 架构文档**：
- `_meta/docs/ARCHITECTURE_CONSTITUTION.md`
- `.claude/scripts/assembler.mjs`（参考实现）

**设计模式**：
- Plugin Pattern
- Lazy Loading
- Cache Strategy

### LiYe OS Integration Points

**参考案例**：
- `.claude/scripts/assembler.mjs` - 远程技能按需加载
- `~/.liye/skill-cache/` - 本地缓存策略

---

## 🔹09. Evaluation & Scoring（绩效 & 质量指标）

### Output Quality Metrics

| 维度 | 权重 | 评分标准 |
|------|------|----------|
| 简化程度 | 35% | 相比原方案减少了多少复杂度 |
| 用户体验 | 30% | 用户感知度（越低越好） |
| 功能完整 | 25% | 需求满足度 |
| 实施可行 | 10% | 技术可行性 |

### Self-Evaluation Checklist

- [ ] 用户需要知道这个机制吗？（应该不需要）
- [ ] 还能再简化吗？
- [ ] 第一版就需要这个功能吗？
- [ ] 维护成本可接受吗？

---

## 🔹10. Feedback / Evolution Loop（进化循环机制）

### 持续改进触发条件

1. **新场景**：遇到新的插件化需求
2. **简化机会**：发现更简单的实现方式
3. **用户反馈**：用户仍感知到复杂度

### 版本记录

| 版本 | 日期 | 变更 |
|------|------|------|
| 1.0 | 2025-12-28 | 初始版本 - 从 awesome-claude-skills 集成实战沉淀 |

---

## 🔗 实战案例

### Case Study: LiYe OS 技能扩展生态

**问题**：
awesome-claude-skills 有 50+ 技能，全部集成会使 LiYe OS 臃肿

**第一轮方案**（过度工程化）：
- 独立 registry 仓库
- registry.yaml + 50 个 pack.yaml
- CLI 命令（liye skill install/list/update）
- 4 周实施周期

**第二轮简化**（最终采用）：
- Fork 上游仓库
- assembler.mjs 内置关键词映射
- curl 直接获取 + 本地缓存
- 1-2 周实施周期
- **用户完全无感知**

**关键洞察**：
> "registry 仓库、CLI 命令、pack.yaml 都是给开发者用的，不是给用户用的。如果用户完全无感知，这些基础设施都是不必要的复杂性。"

---

**END OF SKILL DEFINITION**
